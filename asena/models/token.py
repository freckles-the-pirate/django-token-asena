from django.db import models
from django.utils.translation import ugettext_lazy as _
from asena.utils import random_chars
import string, random


"""
" Token Exceptions
"""

class TokenException(Exception):
    """ A general abstract exception related to tokens.
    "
    """
    def __init__(self, token=None):
        """
        " :param token: the invalid token passed in
        " :type token: object (typically a Token or string)
        """
        self.token = token
        
    def __repr__(self):
        return "%s: %s"%(self.__class__.__name__, self.token)
    
class InvalidTokenException(TokenException):
    """ Thrown when a token is invalid (not in the database)
    """
    def __init__(self, *args, **kwargs):
        super(AutorizationException, self).__init__()
    
class DisabledTokenException(TokenException):
    """ Thrown when a token is valid but has been disabled.
    """
    def __init__(self, *args, **kwargs):
        super(AutorizationException, self).__init__()
    
class AuthorizationException(TokenException):
    """ Thrown when a user has tried to access a page for which they need a 
        token.
    """
    def __init__(self, *args, **kwargs):
        super(AuthorizationException, self).__init__()

class TokenSet(models.Model):
    generated = models.DateTimeField(auto_now=True)
    name = models.CharField(blank=True, null=True, max_length=200)
    disabled = models.BooleanField(default=False)
    
    @classmethod
    def generate_set(Klass, count, length=10, name=None):
        """ Convenience method to generate a set of tokens.
        
         :param count: Number of tokens to generate.
         :type count: int
         
         :param name: An optional name to use for the token set.
         :type name: str
         
         :return: A new TokenSet with the newly-generated tokens.
        """
        token_set = Klass.objects.create(name=name)
        for i in range(0, count):
            Token.generate(length=length, token_set=token_set, comment=name)
        return token_set
            
    def __unicode__(self):
        if self.name:
            return name
        return "Generated %d"%self.generated

    class Meta:
        abstract = False
        app_label = _("asena")
        verbose_name = _("Token Set")
        verbose_name_plural = _("Token Sets")


class Token(models.Model):
    """ A randomly-generated string.
    
    :param value: The value of the string (generated by machine).
    :type value: str
    
    :param comment: A comment for the token (optional).
    :type comment: str
    
    :type token_set: A foreign key to TokenSet.
    :type token_set: models.ForeignKey
    
    """
    value = models.CharField(max_length=200)
    comment = models.TextField(max_length=1000, null=True, blank=True)
    token_set = models.ForeignKey("TokenSet", related_name="tokens",
                                  related_query_name="tokens")
    disabled = models.BooleanField(default=False)
    expiration = models.DateTimeField(null=True, blank=True)
    
    _REQUEST_KEY='asena-token'
    
    @classmethod
    def generate(Klass, length, token_set, comment=None,
                 valid_characters=str(string.letters + string.digits)):
        """ Generate a random token.
        
        :param length: The length of the token.
        :type length: int
        
        :param token_set: The assoicated token_set.
        :type token_set: TokenSet
        
        :param comment: A comment for the token (optional).
        :type comment: str
        
        :param valid_characters: A string of valid characters to use for the
            token. Optional. Default is string.letters + string.digits.
        :type valid_characters: str
        
        :return: The token just generated.
        """
        global random_chars
        val = random_chars(valid_characters, length)
        token = Klass.objects.create(token_set=token_set, comment=comment,
                                    value=val)
        return token
    
    def is_disabled(self):
        return (self.token_set.has_expired() or 
            self.token_set.disabled)
    
    @classmethod
    def exists(self, value):
        return Token.objects.filter(value).exists()
    
    @classmethod
    def is_valid(self, value):
        if Token.exists(value):
            t = Token.objects.get(value=value)
            return not t.is_disabled
        return False
    
    @classmethod
    def request_is_valid(Klass, request):
        """ Given a request, check that the payload contains a token and that
        the token is valid. If it's invalid, throw an exception.
        
        :return: True if a token is valid for a given request. Throws an 
                exception otherwise.
        """
        if request.method == 'POST':
            arr = request.POST
        elif request.method == 'GET':
            arr = request.GET
        else:
            raise AuthorizationException()
        
        if Klass._REQUEST_KEY not in arr:
            raise AuthorizationException()
        
        tok = arr[Klass._REQUEST_KEY]
        qs = Klass.objects.filter(value=tok)
        
        if not qs.exists():
            raise InvalidTokenException(tok)
        
        if qs[0].is_disabled():
            raise DisabledTokenException(qs[0])
        
        return True
    
    def __unicode__(self):
        if self.comment:
            return "%s - %s"%(self.comment, self.value)
        return self.value

    class Meta:
        abstract = False
        app_label = _("asena")
        verbose_name = _("Token")
        verbose_name_plural = _("Tokens")